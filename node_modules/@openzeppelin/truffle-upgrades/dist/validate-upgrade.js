"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateUpgrade = void 0;
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const utils_1 = require("./utils");
const validate_impl_1 = require("./utils/validate-impl");
function isContractClass(object) {
    return typeof object !== 'string' && 'bytecode' in object;
}
async function validateUpgrade(referenceAddressOrContract, newContract, opts = {}) {
    if (isContractClass(referenceAddressOrContract)) {
        const origDeployData = await (0, utils_1.getDeployData)(opts, referenceAddressOrContract);
        if (opts.kind === undefined) {
            opts.kind = (0, upgrades_core_1.inferProxyKind)(origDeployData.validations, origDeployData.version);
        }
        const newDeployData = await (0, utils_1.getDeployData)(opts, newContract);
        (0, upgrades_core_1.assertUpgradeSafe)(newDeployData.validations, newDeployData.version, newDeployData.fullOpts);
        if (opts.unsafeSkipStorageCheck !== true) {
            (0, upgrades_core_1.assertStorageUpgradeSafe)(origDeployData.layout, newDeployData.layout, newDeployData.fullOpts);
        }
    }
    else {
        const referenceAddress = (0, utils_1.getContractAddress)(referenceAddressOrContract);
        const { deployer } = (0, utils_1.withDefaults)(opts);
        const provider = (0, utils_1.wrapProvider)(deployer.provider);
        const deployData = await (0, utils_1.getDeployData)(opts, newContract);
        if (await (0, upgrades_core_1.isTransparentOrUUPSProxy)(provider, referenceAddress)) {
            await (0, validate_impl_1.validateProxyImpl)(deployData, opts, referenceAddress);
        }
        else if (await (0, upgrades_core_1.isBeaconProxy)(provider, referenceAddress)) {
            const beaconAddress = await (0, upgrades_core_1.getBeaconAddress)(provider, referenceAddress);
            await (0, validate_impl_1.validateBeaconImpl)(deployData, opts, beaconAddress);
        }
        else if (await (0, upgrades_core_1.isBeacon)(provider, referenceAddress)) {
            await (0, validate_impl_1.validateBeaconImpl)(deployData, opts, referenceAddress);
        }
        else {
            if (opts.kind === undefined) {
                throw new upgrades_core_1.ValidateUpdateRequiresKindError();
            }
            await (0, validate_impl_1.validateImpl)(deployData, opts, referenceAddress);
        }
    }
}
exports.validateUpgrade = validateUpgrade;
//# sourceMappingURL=validate-upgrade.js.map