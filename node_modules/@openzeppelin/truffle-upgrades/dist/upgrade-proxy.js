"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.upgradeProxy = void 0;
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const utils_1 = require("./utils");
async function upgradeProxy(proxy, Contract, opts = {}) {
    const { deployer } = (0, utils_1.withDefaults)(opts);
    const provider = (0, utils_1.wrapProvider)(deployer.provider);
    const proxyAddress = (0, utils_1.getContractAddress)(proxy);
    const upgradeTo = await getUpgrader(provider, Contract, opts, proxyAddress);
    const { impl: nextImpl } = await (0, utils_1.deployProxyImpl)(Contract, opts, proxyAddress);
    const call = encodeCall(Contract, opts.call);
    const { tx: txHash } = await upgradeTo(nextImpl, call);
    Contract.address = proxyAddress;
    Contract.transactionHash = txHash;
    const contract = new Contract(proxyAddress);
    contract.transactionHash = txHash;
    return contract;
}
exports.upgradeProxy = upgradeProxy;
async function getUpgrader(provider, contractTemplate, opts, proxyAddress) {
    const adminAddress = await (0, upgrades_core_1.getAdminAddress)(provider, proxyAddress);
    const adminBytecode = await (0, upgrades_core_1.getCode)(provider, adminAddress);
    const overrides = opts.txOverrides ? [opts.txOverrides] : [];
    if ((0, upgrades_core_1.isEmptySlot)(adminAddress) || adminBytecode === '0x') {
        // No admin contract: use ITransparentUpgradeableProxyFactory to get proxiable interface
        const ITransparentUpgradeableProxyFactory = (0, utils_1.getITransparentUpgradeableProxyFactory)(contractTemplate);
        const proxy = new ITransparentUpgradeableProxyFactory(proxyAddress);
        return (nextImpl, call) => {
            return call ? proxy.upgradeToAndCall(nextImpl, call, ...overrides) : proxy.upgradeTo(nextImpl, ...overrides);
        };
    }
    else {
        // Admin contract: redirect upgrade call through it
        const AdminFactory = (0, utils_1.getProxyAdminFactory)(contractTemplate);
        const admin = new AdminFactory(adminAddress);
        return (nextImpl, call) => {
            return call
                ? admin.upgradeAndCall(proxyAddress, nextImpl, call, ...overrides)
                : admin.upgrade(proxyAddress, nextImpl, ...overrides);
        };
    }
}
function encodeCall(factory, call) {
    if (!call) {
        return undefined;
    }
    if (typeof call === 'string') {
        call = { fn: call };
    }
    const contract = new factory.web3.eth.Contract(factory._json.abi);
    return contract.methods[call.fn](...(call.args ?? [])).encodeABI();
}
//# sourceMappingURL=upgrade-proxy.js.map